# This file is part of CherryPy <http://www.cherrypy.org/>
# -*- coding: utf-8 -*-
# vim:ts=4:sw=4:expandtab:fileencoding=utf-8
"""Digital Signature Authentication tool.

This module provides a CherryPy 3.x tool which implements
the server-side of RSA Digital Signature Authentication
(with PKCS#1 1.5 padding), as described in :rfc:`7427`.

"""

import binascii
import base64

import cherrypy
from cryptography.exceptions import InvalidSignature
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives import serialization
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.asymmetric import padding


def signature_auth(realm, key_file, debug=False):
    """Perform digital signature authentication for the given request..

    If the request has a 'signature' header with a signature and a message,
    this tool attempts to validate the signature with the corresponding
    message.  If the request has no 'signature' header, or if it does but
    the signature and the message do not match, i.e. if authentication fails,
    the tool sends a 401 response with a 'WWW-Authenticate' Basic header.


    realm
        A string containing the authentication realm.

    key_file
        Path to the public key PEM file

    debug
        Whether to print auth logs

    """
    if '"' in realm:
        raise ValueError('Realm cannot contain the " (quote) character.')
    request = cherrypy.serving.request

    sign_header = request.headers.get('signature')
    message_header = request.headers.get('message')

    if sign_header is not None and message_header is not None:
        # split() error, base64.decodestring() error
        msg = 'Bad Request'
        with cherrypy.HTTPError.handle((ValueError, binascii.Error), 400, msg):

            # keys = auth_header.split('-')
            signature = sign_header
            message = message_header

            if _verify_signature(signature, message, key_file):
                if debug:
                    cherrypy.log('Auth succeeded', 'TOOLS.AUTH_SIGNATURE')
                return  # successful authentication

    # Respond with 401 status and a WWW-Authenticate header
    cherrypy.serving.response.headers[
        'www-authenticate'] = 'Basic realm="%s"' % realm
    raise cherrypy.HTTPError(
        401, 'You are not authorized to access that resource')


def _verify_signature(signature, message, key_file):
    """Verify the signature and message.

    Given the signature, the corresponding message and
    the public key, verifies that the signature was generated by
    using the associated private key.


    signature
        Signature generated by signing a message.

    message
        The message that was signed.

    key_file
        Path to the private/public key PEM file


    Returns:
        True, if the signature and the message match, otherwise False

    """
    # signature is decoded to bytes from string, then b64decoded
    signature = base64.b64decode(signature.encode())

    message = message.encode('utf-8')

    with open(key_file, 'rb') as file:
        public_key = serialization.load_pem_public_key(
            file.read(),
            backend=default_backend()
        )

    result = None

    try:

        public_key.verify(
            signature,
            message,
            padding.PKCS1v15(),
            hashes.SHA256()
        )

    except InvalidSignature:
        cherrypy.log('InvalidSignature')
        result = False

    else:
        result = True

    finally:
        pass

    return result
